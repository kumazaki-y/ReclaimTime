# Task-Memo

スキル向上を目的にポートフォリオとしてタスク管理アプリを作成しました。

シングルページアプリケーション (SPA) として主に下記の構成で作成しています。

- フロントエンドは **TypeScript / React**
- バックエンドは **Ruby on Rails**
- インフラは **Vercel (静的サイト) / AWS(API)**
- モノレポ構成
- バックエンドとフロントエンドの開発環境は両方ともDockerを使用

詳細は後述の「開発環境 (フロントエンド)」「開発環境 (バックエンド)」「本番環境」をご覧ください。

## 目次

- [機能](#機能)
- [開発環境 (フロントエンド)](#開発環境-フロントエンド)
- [開発環境 (バックエンド)](#開発環境-バックエンド)
- [本番環境](#本番環境)
  - [インフラ構成図](#インフラ構成図)
- [ER図](#ER図)
- [使用技術 (フロントエンド)](#使用技術-フロントエンド)
- [使用技術 (バックエンド)](#使用技術-バックエンド)
- [使用技術 (その他)](#使用技術-その他)
- [画面](#画面)

## 画面

- ホーム
- ログイン
- ユーザー登録
- メールアドレス認証
  - 認証確認通知
  - 認証用メール
  - 未認証警告+再送信ボタン
- パスワードリセット
  - 再設定リクエスト
  - 再設定用メール
  - 再設定画面
- ボードCRUD
- タスクCRUD
- 検索
- 絞り込み
- 並び替え

## 機能

### 認証
- ユーザー登録
- メールアドレス認証
  - 認証メール再送信
  - 未認証ユーザー削除 (定期処理)
- ログイン / ログアウト
  - Cookie / セッション
- ゲストユーザーログイン
- パスワードリセット
  - リセットメール認証

### タスク管理
- 作成 / 表示 / 更新 / 削除
- ボード（タスクグループ） 作成 / 表示 / 更新 / 削除
- タスク(各ボードに紐づく) 作成 / 表示 / 更新 / 削除
- 検索
- 絞り込み
- 並び替え    
  - ドラッグ&ドロップ  
  - 状態保持
- ページネーション

## 開発環境 (フロントエンド)
フロントエンドにはTypeScriptとReactを採用しています。

TypeScriptを使用することで型安全性が強化され、開発効率とコードの可読性が向上しています。

ビルドツールにはViteを使用しており、迅速なビルドとホットリロードによって開発体験が快適になります。

実行環境のバージョン:

- Vite: 5.4.8
- Yarn: 1.22.22
- Node.js: v20.16.0
- TypeScript: 5.6.2
- React: 18
ブラウザにはChrome (Mac) を使用しています。

## 開発環境 (バックエンド)

バックエンドにはRuby on Railsを使用して、以下の構成で統合開発環境を整えています。

メール送信にはActionMailerを使用し、自分が所有しているgmailから送信テストを実行。

- Ruby (3.3.4)
- Ruby on Rails (7.1.3.4)
- MySQL (8.0.40)


## 本番環境

フロントエンドで生成された静的ファイルのホスティングには、Vercelを採用しました。

バックエンドAPIの実行にはAWSを利用しています。

各サービスの役割は以下の通りです。

- **Vercel**：静的ファイルホスティング
- **VPC**：メインネットワーク範囲を管理 (CIDR: 10.0.0.0/16)
- **IGW**：パブリックサブネット用のインターネットゲートウェイを設定
- **パブリックサブネット**：フロントエンドやロードバランサーなど、外部と通信が必要なリソースを配置
- **ALB (Application Load Balancer)**：外部からのアクセスを管理し、ECSのタスクにリクエストを分散
- **プライベートサブネット**：データベースやアプリケーションサーバーを配置し、外部からのアクセスを制限
- **ECS (Elastic Container Service)**：コンテナオーケストレーションを行い、アプリケーションのデプロイを管理
- **RDS (Aurora MySQL 8.0.3.05.2)**：リレーショナルデータベース (RDB)
- **ECR (Elastic Container Registry)**：アプリケーションのDockerイメージを保存
- **IAM (ユーザー、ロール、ポリシー)**：アクセス管理
- **Amazon SES (SMTPインターフェイス)**：カスタムドメインのメール送信
- **Systems Manager (パラメータストア)**：機密情報の保管
- **Certificate Manager**：SSL/TLS証明書発行 (API用カスタムドメイン)
- **CloudWatch (ログ)**：ログ管理

## インフラ構成図

アプリケーションの基本的な処理の流れは以下の通りです。

1. ユーザーはVercelにデプロイされたフロントエンドアプリケーションのURLからアクセスします。
2. APIが必要なリクエストは、パブリックサブネット内のALB (Application Load Balancer) を通じてバックエンドに送信されます。
3. ALBは、ECS (Elastic Container Service) によって管理されるコンテナ化されたRailsアプリケーションにリクエストを転送します。
4. ECSは、プライベートサブネット上でアプリケーションを実行し、以下のような処理を行います。
   - RDS (Aurora MySQL) へのデータベースアクセス
   - Amazon SESを利用したメール送信
   - CloudWatchにログを送信し、監視・管理を実行

以下の図は、この処理の流れを示しています。


![インフラ構成図](https://drive.google.com/uc?id=1Ugx0KOCRQXL6NkSGPJcOgJLQ8N63ds6h)


インフラは業務での実践を想定し構成しました。

今回のアプリには過剰かもしれない要素もありますが、今後の業務でのインフラ設計や運用に役立つ知識を身につけるために組み込み、実務レベルで評価されるインフラ構成を目指しています。

以下、各ポイントについて説明します。

### ECSとECRの連携
アプリケーションのコンテナイメージは、ECR（Elastic Container Registry）に保存されています。

ECS（Elastic Container Service）は、デプロイ時や更新プロセスで、このECRから最新のDockerイメージを取得し、アプリケーションのコンテナとして実行します。

この構成により、アプリケーションの更新が簡易かつ効率的に行えるため、迅速なデプロイが可能です。

また、ECRを利用することでセキュアにコンテナイメージを管理でき、信頼性の高い環境を構築しています。この流れは、実際の業務での継続的デリバリーを想定して取り入れました。

### ECSからのCloudWatchへのログ送信
ECSは、アプリケーションの動作ログやエラーログをCloudWatchに送信しています。

これにより、エラー発生時の監視やトラブルシューティングが迅速に行えるようになります。

さらに、パフォーマンスのモニタリングやリソース管理にも役立てており、安定したサービス運用が実現できます。

CloudWatchによる監視は、業務での障害対応やパフォーマンス管理に活用することを見越して導入しました。

### ALB（Application Load Balancer）とInternet Gatewayの役割
ALBは、インターネットゲートウェイ（IGW）を通じてユーザーからのリクエストを受け取り、パブリックサブネット内で稼働しています。

ロードバランサーとして、ユーザーからのリクエストをECSに振り分け、スケーラビリティと冗長性を確保しています。

また、HTTPS通信が可能なため、セキュリティを担保したアクセス管理が実現されています。

これは、負荷分散とセキュリティの確保を目指し、実務でのスケーラブルな設計を意識して取り入れました。

### RDSの配置理由とプライベートサブネットのセキュリティ
RDS（Aurora MySQL）は、プライベートサブネット内に配置されています。

この配置により、外部からの直接アクセスが遮断され、データベースのセキュリティが強化されています。

アプリケーションサーバーのECSのみがRDSにアクセスできるよう設定されており、安全なデータ保護が可能です。

このサブネット分離の設計は、業務でのセキュリティを重視したデータ保護を意識して導入しました。

### Lambdaによる未認証ユーザーの自動削除

Lambdaを用いることで、**未認証ユーザーの自動削除**機能を実現しました。
- AWS EventBridgeを利用してスケジュール式で定期実行
- AWS Secrets Managerを活用し、認証情報を安全に管理
- RDS（Aurora MySQL）との通信をVPC内に限定する設計により、セキュリティを向上

#### **動作の流れ**
1. **EventBridgeによるスケジュール実行**  
   AWS EventBridge（旧CloudWatch Events）のスケジュール式を利用し、Lambda関数が定期的に自動でトリガーされます。

   この設定により、運用者が手動で削除タスクを実行する必要がなくなり、運用の効率化が実現されます。

2. **Secrets Managerを利用した認証情報の安全な管理**  
   Lambda関数がデータベースへ接続する際の認証情報は、AWS Secrets Managerに格納されています。これにより、環境変数やコード内に平文で認証情報を記載するリスクを排除し、セキュリティを向上させています。

3. **プライベートサブネット内のRDSとの接続**  
   Lambda関数は、VPCに配置され、プライベートサブネット内のRDSにアクセスできるセキュリティグループを適用しています。この設計により、LambdaとRDS間の通信は完全に内部ネットワーク内で行われ、外部からの不正アクセスを防ぎます。

## ER図

![ER図](https://drive.google.com/uc?export=view&id=1wmSFyD00zgSvfsyQ_NJvm8xy4nzcXmDK)

上記のER図は、タスク管理アプリケーションのためのデータベース構造を表しています。

主要なテーブルはusers、boards、tasksの3つで構成され、usersは認証情報を保持し、各ユーザーが作成したタスクの管理をサポートしています。

boardsはタスクをグループ化する単位であり、各boardは一人のユーザーに紐づけられます。

さらに、tasksは具体的なタスクの詳細を管理し、それぞれが特定のboardに所属しています。

このER図の作成には、dbdiagram.ioを使用しました。

このサービスはschema.rbなどの実際のモデル定義を貼り付けるだけでER図を生成します。

## 使用技術 (フロントエンド)

- **TypeScript (5.5.3)** - 静的型付けのプログラミング言語
- **React (18)** - UI構築ライブラリ
- **React Router Dom (6.26.1)** - ルーティング管理
- **Chakra UI (2.10.1)** - UIコンポーネントライブラリ
- **SWR (2.2.5)** - データフェッチングライブラリ
- **React Hook Form (7.53.1)** - フォームのバリデーションと管理
- **Yup (1.4.0)** - スキーマベースのバリデーションライブラリ
- **ESLint/Prettier/Stylelint** - コード品質と一貫性を保つためのツール

### TypeScript
TypeScriptを採用した主な理由は、静的型付けによる型安全性の確保と、コードの可読性・保守性の向上です。JavaScriptの柔軟性は残しつつ、型チェックを通じてバグの早期発見と予防が可能です。特にチーム開発においては、型情報があることで新しい開発者もコードを理解しやすく、意図しない型エラーが防げます。また、JavaScriptに比べてTypeScriptはIDEの補完機能が充実しており、生産性の向上につながります。VueやAngularでもTypeScriptは使用可能ですが、Reactのエコシステムとの相性が良いTypeScriptを選択しました。

### React + React Router Dom
UI構築には、再利用性とコンポーネントベースの開発手法に優れたReactを採用しました。Reactは他のフレームワーク（VueやAngular）と比較して、エコシステムが豊富であり、最新の開発トレンドにも柔軟に対応できます。特にReact Router Domを使用することで、シングルページアプリケーションにおける直感的かつ高速なページ遷移が実現でき、ユーザー体験を大幅に向上できます。VueやAngularに比べ、Reactのシンプルな設計と柔軟性が、スピーディーで拡張性の高い開発に適していると判断しました。

### Chakra UI + Emotion
UIコンポーネントライブラリには、開発速度と視覚的一貫性を重視してChakra UIを選定しました。Chakra UIはデザインガイドラインに基づいた豊富なコンポーネントを提供し、ビジュアルの一貫性が保てるため、デザイナーとエンジニア間での調整がスムーズに行えます。さらに、柔軟なスタイリングを可能にするEmotionを組み合わせることで、Tailwind CSSやMaterial-UIよりもデザインの自由度と統一感が得られます。特にChakra UIはアトミックデザインの構造にも適しており、迅速にモダンなUIを構築できる利点があります。

### SWR
SWRは、リアルタイムなデータフェッチングとキャッシュ管理が必要な環境でのパフォーマンス最適化に優れたライブラリです。SWRは、ReduxやReact Queryと比較しても軽量で、データのキャッシュ更新や自動再フェッチ機能が標準で備わっています。API通信の頻度が高い本プロジェクトでは、シンプルで直感的なSWRの利用により、エンドユーザーへの高速なレスポンスと効率的なデータ更新が実現できました。特に、Reactの標準APIのfetchよりも柔軟で、リアルタイムデータ更新に優れている点が採用の決め手です。

### React Hook Form + Yup
フォームバリデーションには、軽量で高速なReact Hook Formと、柔軟なスキーマバリデーションを提供するYupを組み合わせました。React Hook Formは、ネイティブのForm APIを活用するため、再レンダリングが少なく、他のフォーム管理ライブラリ（Formikなど）に比べてパフォーマンスが向上します。また、Yupとの連携により、複雑なバリデーションを簡潔に記述でき、ユーザー体験を向上できます。この組み合わせにより、バリデーションとエラーハンドリングがシンプルになり、開発生産性が向上しました。

### ESLint / Prettier / Stylelint
コードの品質を保つために、ESLintとPrettier、Stylelintを導入しました。ESLintはJavaScript/TypeScriptのエラーチェック、Prettierはコードの整形、StylelintはCSSの品質管理に使用しています。これらのツールを組み合わせることで、コードの一貫性が確保され、コードレビューの効率が向上しました。これにより、チーム全体でのコードスタイルの統一が図れ、メンテナンス性が向上しています。特に、複数人の開発者が関わるプロジェクトにおいて、チーム内での共通ルールの徹底が容易になります。

### テスト方法
テストにはJestの代わりに**curlコマンド**を使用しています。APIエンドポイントを直接テストするcurlは、軽量かつ直感的で、簡易的な動作確認には十分です。特に、APIのステータス確認やデバッグにおいて、過度な設定が不要で即時性が求められる場面において、curlは非常に効果的です。Jestによるユニットテストも考慮しましたが、今回のプロジェクト規模ではcurlによる直接テストの方が効率的であると判断しました。これにより、迅速にAPIの動作を確認し、開発スピードを維持しています。

## 使用技術（バックエンド）

- **Ruby (3.3.4)** - シンプルで直感的な文法を持つプログラミング言語。
- **Rails (7.1.4)** - Webアプリケーションフレームワーク。
- **MySQL (mysql2 ~> 0.5)** - リレーショナルデータベース。
- **Puma (6.4.2)** - 高性能なマルチスレッド対応アプリケーションサーバー。
- **Devise (4.9.4)** - ユーザー認証ライブラリ。
- **Devise Token Auth (1.2.3)** - トークンベースの認証をサポートし、セキュアなAPI通信を実現。
- **AWS Secrets Manager (1.108.0)** - 機密情報の管理。
- **Dotenv (3.1.2)** - 環境変数の管理。
- **Rack CORS (2.0.2)** - CORS設定（クロスオリジンリソース共有）を管理。

#### Ruby + Rails
バックエンドにはRuby on Railsを採用しました。その主な理由は、**高い開発効率と迅速なプロトタイピング能力**です。Railsは、MVCアーキテクチャを提供し、コントローラー、モデル、ビューの各層にコードを分割することで、機能の追加や変更が容易に行えます。さらに、**ActiveRecordやActionCableなどの豊富な標準機能**が含まれており、外部ライブラリ（Gem）を活用することで、ログイン認証、メール配信、ファイルアップロードなどの一般的な機能を短期間で実装できます。  
Railsは、他のフレームワーク（DjangoやNode.jsのExpressなど）と比較しても、**フルスタックかつ「開発者の幸福」を重視**している点で優れており、特にスピードが重視されるプロジェクトでは高いパフォーマンスを発揮します。また、RubyとRailsのコミュニティは活発でドキュメントも豊富なため、トラブル解決が迅速に行える点も採用の大きな理由です。

#### MySQL
データベースにはMySQLを選定しました。MySQLは**パフォーマンスの高さ、安定性、シンプルな運用**に強みがあり、データの一貫性とスケーラビリティを重視するシステムに適しています。PostgreSQLも候補にありましたが、MySQLは特に読み込み速度とシンプルな管理が求められる環境で信頼性が高く、Railsと組み合わせた経験が豊富なため、今回のプロジェクトにはMySQLが最適と判断しました。  
また、MySQLは広く普及しており、**エンジニア間での知見が豊富**であるため、チーム開発やサポート体制の整備においても有利です。

#### Puma
アプリケーションサーバーにはPumaを採用しました。Pumaは**マルチスレッド対応で、リクエストの同時処理能力が高い**ため、アクセス集中に強い構成を実現します。特に、PumaはRailsに標準で採用されており、Railsとの親和性が高く、設定が簡単でありながら高いパフォーマンスを提供します。Unicornも候補にありましたが、Pumaは**スレッドベースで効率的にスケール**でき、サーバーリソースを効果的に利用できるため、選定しました。

#### Devise + Devise Token Auth
ユーザー認証にはDeviseとDevise Token Authを組み合わせて使用しています。DeviseはRailsで広く使われており、**高いセキュリティと柔軟な認証機能の追加**が可能です。メール認証やパスワードリセットなどの一般的な認証機能が容易に実装でき、セキュアで信頼性のあるユーザー認証を短期間で導入できました。  
また、APIベースのアプリケーションと連携するため、トークンベースの認証が必要であり、**Devise Token Authの導入によりSPAやモバイルアプリケーション**ともシームレスに連携が可能です。この組み合わせにより、シンプルかつ安全に認証機能を実装できることが大きなメリットとなりました。

#### AWS Secrets Manager
AWS Secrets Managerは、**機密情報を安全に保管・管理するためのツール**として採用しました。データベースのパスワードやAPIキーなどの機密情報を暗号化して保管し、アプリケーションが必要な時だけ動的に取得できるため、従来の環境変数管理よりも**セキュリティが向上**します。自動ローテーション機能も備えており、セキュリティの強化に加え、システム管理の手間を削減できるため、プロジェクトの安定運用に貢献します。

#### Dotenv
開発・本番環境での設定を柔軟に切り替えるため、Dotenvを使用しています。Dotenvは**開発段階での環境変数管理をシンプルに行える**ため、異なる環境ごとの設定を簡単に変更でき、セキュリティの確保と同時に開発効率も向上します。また、AWS Secrets Managerなどの高度な管理ツールとも共存でき、**開発の初期段階での迅速な対応が可能**です。

#### Rack CORS
Rack CORSを利用し、**クロスオリジンリソース共有（CORS）を適切に管理**しています。これにより、異なるドメインからのAPIリクエストを安全に許可し、ユーザーエクスペリエンスを損なうことなくセキュリティを確保します。特にフロントエンドとの連携を考慮した際に、CORSの適切な設定は重要であり、セキュリティ要件を満たすための基本的なツールとして採用しました。


### 使用技術 (その他)

- **Docker** - コンテナ管理ツール

Dockerは、アプリケーションの動作環境をコンテナとして管理するために採用しました。Dockerを使用することで、**アプリケーションの環境構築や依存関係の管理が容易**になり、異なる環境間での動作の一貫性が確保されます。特に、開発環境と本番環境を同一のコンテナイメージで構築できるため、本番環境での「動かない」問題を減らし、デプロイの信頼性が向上します。  
また、Dockerはマイクロサービスアーキテクチャにも対応しやすく、**複数のサービスを効率的に管理**できる点も利点です。従来の仮想マシンと比較して、Dockerは軽量で、リソース効率が良いため、スピードと柔軟性が求められる開発プロジェクトに最適です。
チームメンバー間で統一された開発環境を容易に共有できるため、実務での開発効率が大幅に向上することを意識して採用しました。


## ディレクトリ構成

本プロジェクトのディレクトリ構成は、保守性と拡張性を重視し、アトミックデザインの概念に基づいて設計されています。
Reactのディレクトリ構成には厳密な規定がないため、開発における一貫性を保つためにアトミックデザインの考え方を採用しました。
アトミックデザインは、コンポーネントを「再利用可能なUIの部品」として階層的に構成するため、長期的なメンテナンスや機能の拡張がしやすいという利点があります。
また、コンポーネント単位での開発が容易になることで、開発スピードの向上にも寄与しています。

```plaintext
src/
├── App.tsx             # アプリのメインコンポーネント
├── components/         # UIコンポーネント（アトミックデザインに基づく構成）
│   ├── atoms/          # 最小単位のコンポーネント（ボタン、入力フィールドなど）
│   ├── ecosystems/     # より高度な機能を組み合わせた複合コンポーネント
│   ├── environments/   # コンポーネントの特定環境設定やデザインの切り替え
│   ├── molecules/      # Atomsを組み合わせたやや複雑なコンポーネント（入力フォームなど）
│   ├── organisms/      # Moleculesを組み合わせた機能単位のコンポーネント（ナビゲーションバーなど）
│   └── templates/      # ページ構成に使うテンプレート（ページの枠組みなど）
├── features/           # アプリケーションの特定の機能を構成
│   ├── auth/           # 認証に関する機能（ログイン・ログアウト処理など）
│   └── hooks/          # 特定の機能に関連するカスタムフック
├── main.tsx            # アプリのエントリーポイント
├── routes/             # ルーティング関連の設定
├── urls/               # APIやリンクのURL管理
└── utils/              # ユーティリティ関数やAPIリクエスト関連
```

components フォルダでは、アトミックデザインをベースにコンポーネントを階層的に管理しています。

features フォルダは、特定の機能に関連するコードを集約するためのフォルダです。
認証機能 (auth) など、アプリケーション内で役割が明確な機能ごとに分けることで、コードの分かりやすさと再利用性を高めています。

utils は、APIリクエストや共通の関数をまとめたフォルダです。
汎用的なコードをここに配置することで、他のフォルダからも容易に利用できるようにしています。

urls フォルダにはAPIのエンドポイントやルートのURLを一元管理しています。
これにより、APIの変更に伴う修正を一箇所で行うことが可能となり、メンテナンス性が向上しています。

この構成により、アトミックデザインのメリットを最大限に活かしつつ、機能ごとに整理されたフォルダ構成で効率的な開発環境を実現しています。
将来的に機能が増加しても、再利用性や拡張性の面で柔軟に対応できるような設計を心掛けています。

## 画面





