# Task-Memo: 詳細ドキュメント

本ドキュメントでは、エンジニア向けに技術的な詳細と全体的な機能を解説します。
本プロジェクトは実務でのチーム開発を想定し、RailsとReactを組み合わせたモノレポ構成での開発に挑戦しました。
同様に、インフラもAWSでの構築に挑戦しています。

人事担当者や非エンジニア向けの[概要ドキュメント]()はこちら。

## 目次
- [機能一覧](#機能一覧)
- [ディレクトリ構成](#ディレクトリ構成)
- [フロントエンド](#フロントエンド)
  - [使用技術](#主な使用技術)
  - [技術選定理由](#技術選定理由)
  - [開発環境](#開発環境)
- [バックエンド](#バックエンド)
  - [使用技術](#使用技術-1)
  - [技術選定理由](#技術選定理由-1)
  - [開発環境](#開発環境)
  - [データベース構造](#データベース構造)
- [インフラ](#インフラ)
  - [使用技術](#使用技術-2)
  - [インフラ構成図](#インフラ構成図)
  - [採用技術による効果](#採用技術による効果)
- [アプリ画面](#アプリ画面)

## 機能一覧
タスク管理アプリに求められる基本的な機能を導入しています。  
実際の動作イメージは[アプリ画面](#アプリ画面)から確認ください。
### 認証
- ユーザー登録
- メールアドレス認証（認証メール再送信、未認証ユーザー削除）
- ログイン / ログアウト（Cookie / セッション管理）
- ゲストログイン
- パスワードリセット（リセットメール認証）
### タスク管理
- 作成 / 表示 / 更新 / 削除
- ボード（タスクグループ）管理
- タスクの検索、絞り込み
- 並び替え（ドラッグ＆ドロップ対応、状態保持）

## 開発環境
### プロジェクト全体のディレクトリ構成
```plaintext
project/
├── .vscode/                # 開発環境の設定
│   ├── settings.json       # VSCodeのエディタ設定
├── api/                    # バックエンド (Rails)
│   ├── Gemfile             # 依存関係管理
│   └── app/                # Railsのアプリケーションコード
├── front/                  # フロントエンド (React)
│   ├── package.json        # 依存関係管理
│   └── src/                # Reactのアプリケーションコード
├── docs/                   # ドキュメント管理
│   └── README.md           # プロジェクトの詳細ドキュメント
├── docker-compose.yml      # 開発環境の統一管理
└── README.md               # プロジェクトの概要ドキュメント
```
### 技術選定・構成の理由
プロジェクト全体の主なディレクトリ構成は以下のとおりです。  
本プロジェクトは個人開発ですが、**Docker-Compose**でフロントエンドとバックエンドを統一管理する**モノレポ構成**で開発を進めました。  
実務でのチーム開発を見据え、以下のような効率的な開発環境の構築を目標に挑戦しています。

#### Dockerによる開発環境の統一化
Dockerは開発環境をコンテナとして管理し、ローカルから分離した状態で軽量に実行できるツールです。  
チームメンバー間で統一された開発環境を容易に共有でき、開発効率が大幅に向上するため採用しました。
以下のように効率的なセットアップを実現しています。
 - **環境の一貫性**  
   フロントエンド（React）とバックエンド（Rails）に個別のDockerファイルを作成。  
   将来的なチーム開発における**「自分の環境では動く」といった問題**を防止。  
   本番環境では、Dockerファイルから作成したイメージをECRに格納し、AWS ECSでコンテナをデプロイ。  
   ローカル環境と同一の構成を本番でも再現し、環境間の一貫性を保持。
 - **環境構築の効率化**
   Docker Composeによって一元的にアプリを起動・管理できる仕組みを整え、環境構築にかかる時間を短縮。

#### モノレポ構成による明確な役割分担とコードベースの一元化
モノレポ構成では、一つのリポジトリ内で複数の技術スタックコードを一元管理します。
本プロジェクトは、異なる技術スタックのバックエンド（Rails）とフロントエンド（React）のコードを個別に作成。  
両者を同一リポジトリに集約し、以下のようにメンテナンス性を向上させています。
- **役割分担の明確化**  
  フロントエンド（`front/`）はUI/UX設計とクライアント側のロジックを担い、バックエンド（`api/`）はAPI設計とデータ処理を担当。  
  技術スタックごとに分離された構造により、それぞれの開発やメンテナンスが容易。
 - **プロジェクト全体の変更管理の効率化**  
  バックエンドAPIのエンドポイント設計の更新時に、フロントエンド側で必要な修正箇所を同リポジトリ内で即座に確認可能。  
  リポジトリを1つに統一することで、複数のリポジトリを行き来する必要がなく、開発効率が向上。

## フロントエンド
本プロジェクトのフロントエンドは、TypeScriptとReactを使用し、モダンな設計と高速なユーザー体験の実現を目指しました。  
また、UIはChakra UIを活用し、ユーザーフレンドリーで統一感のあるデザインを心がけています。  
ビルドツールにはViteを採用し、開発効率と高速なホットリロードを実現しています。 

### 使用技術
今回のプロジェクトでは、フロントエンドのモダンな技術を試して一つのアプリを作り切ること目標にしました。  
TypeScriptやReact、Chakra UIなど、現在多くの開発現場で採用されている技術を調査し、プロジェクトに取り入れました。  
今後は要件に応じて最適な技術を選定できるよう、さらに知識を深めたいと考えています。
 
- **TypeScript (5.5.3)**  
  静的型付けにより型エラーを未然に防止し、コードの保守性を向上。  
  IDEの補完機能が充実しており、開発効率が向上。
- **React (18) ＋ React Router Dom (6.26.1)**  
  コンポーネントベースの設計で再利用性が高く、SPAのページ遷移を実現。
  SPAで直感的な操作を実現。
- **Chakra UI (2.10.1)**  
  デザインの一貫性を確保しつつ、短期間でモダンなUIを構築。
- **SWR (2.2.5)**  
  軽量なデータフェッチングライブラリを活用し、リアルタイム通信の効率化を試行。  
  （HomeコンポーネントでAPIデータの取得とキャッシュ機能）
- **React Hook Form (7.53.1) + Yup (1.4.0)**  
  軽量なフォーム管理とスキーマベースのバリデーションにより、簡潔かつ効率的なフォーム実装を実現。
- **ESLint / Prettier / Stylelint**  
  コード品質の維持とスタイル統一を実現し、メンテナンス性を向上。
- **Vite (5.4.8)**  
  ビルド速度とホットリロード性能を重視し、開発効率を向上。

### フロントエンドのディレクトリ構成
本プロジェクトでは、Reactの自由度の高いディレクトリ設計に対し、保守性と拡張性を重視して**アトミックデザイン**を採用しました。  
アトミックデザインは、コンポーネントを「再利用可能なUI部品」として階層的に整理し、機能の拡張や長期的なメンテナンスを容易にするアプローチです。

```plaintext
src/
├── App.tsx             # アプリのメインコンポーネント
├── components/         # UIコンポーネント（アトミックデザインに基づく構成）
│   ├── atoms/          # 最小単位のコンポーネント（ボタン、入力フィールドなど）
│   ├── ecosystems/     # より高度な機能を組み合わせた複合コンポーネント
│   ├── environments/   # コンポーネントの特定環境設定やデザインの切り替え
│   ├── molecules/      # Atomsを組み合わせたやや複雑なコンポーネント（入力フォームなど）
│   ├── organisms/      # Moleculesを組み合わせた機能単位のコンポーネント（ナビゲーションバーなど）
│   └── templates/      # ページ構成に使うテンプレート（ページの枠組みなど）
├── features/           # アプリケーションの特定の機能（認証など）
├── main.tsx            # アプリのエントリーポイント
├── routes/             # ルーティング関連の設定
├── urls/               # APIやリンクのURL管理
└── utils/              # ユーティリティ関数やAPIリクエスト関連
```
#### 主なフォルダ構成と役割
- components  
  アトミックデザインの考え方をベースにコンポーネントを階層的に管理。
- features  
  認証など、アプリケーションの主要機能を集約。  
- utils  
  APIリクエストや汎用的な関数を集約し再利用性を向上。
- urls  
  API関連のルーティング設定を一元管理し、再利用性を向上。
  
この構成により、UIとロジックが分離され、機能ごとに整理された効率的な開発環境を実現しました。  
将来的な機能追加や変更にも柔軟に対応できる設計を心がけています。

## バックエンド
バックエンドは、Ruby on Railsを用いて構築し、トークンベースの認証やAPI設計を実現しています。  
データベースにはMySQLを使用し、高速で信頼性の高いデータ処理を提供します。
バックエンドにはRuby on Railsを使用して、以下の構成で統合開発環境を整えています。
メール送信にはActionMailerを使用し、自分が所有しているgmailから送信テストを実行。

### 主な使用技術
- Ruby (3.3.4): シンプルで直感的な文法を持つプログラミング言語。
- Rails (7.1.4): 高い開発効率と豊富なエコシステム。
- MySQL (8.0.40): 高速な読み込みと安定性。
- Puma (6.4.2): マルチスレッド対応のアプリケーションサーバー。
- Devise + Devise Token Auth: 安全なトークンベースの認証。

- **Ruby (3.3.4)** - シンプルで直感的な文法を持つプログラミング言語。
- **Rails (7.1.4)** - Webアプリケーションフレームワーク。
- **MySQL (mysql2 ~> 0.5)** - リレーショナルデータベース。
- **Puma (6.4.2)** - 高性能なマルチスレッド対応アプリケーションサーバー。
- **Devise (4.9.4)** - ユーザー認証ライブラリ。
- **Devise Token Auth (1.2.3)** - トークンベースの認証をサポートし、セキュアなAPI通信を実現。
- **AWS Secrets Manager (1.108.0)** - 機密情報の管理。
- **Dotenv (3.1.2)** - 環境変数の管理。
- **Rack CORS (2.0.2)** - CORS設定（クロスオリジンリソース共有）を管理。

### 技術選定理由
- Rails: MVCアーキテクチャにより迅速な開発が可能。豊富なライブラリ（Gem）を活用し、認証やバリデーションなどの機能を効率的に実装。
- MySQL: データ整合性と高速な読み書き性能を重視し採用。
- Devise Token Auth: SPAやモバイルアプリに対応したトークンベース認証を簡単に実装。

### 開発環境
- Docker: ローカル開発環境と本番環境を一致させ、動作の一貫性を確保。
- AWS Secrets Manager: 機密情報をセキュアに管理し、運用負担を軽減。
- Rack CORS: フロントエンドと安全に連携するためのCORS設定を実装。

### データベース構造
データベースは、users, boards, tasksの3つの主要テーブルで構成されています。
- users: 認証情報を管理。
- boards: タスクを分類するグループ。
- tasks: 各タスクの詳細情報を管理。
以下はデータベースのER図です。

![ER図](./front/public/images/ER.png)

上記のER図は、タスク管理アプリケーションのためのデータベース構造を表しています。
主要なテーブルはusers、boards、tasksの3つで構成され、usersは認証情報を保持し、各ユーザーが作成したタスクの管理をサポートしています。
boardsはタスクをグループ化する単位であり、各boardは一人のユーザーに紐づけられます。
さらに、tasksは具体的なタスクの詳細を管理し、それぞれが特定のboardに所属しています。
このER図の作成には、dbdiagram.ioを使用しました。
このサービスはschema.rbなどの実際のモデル定義を貼り付けるだけでER図を生成します。

### 採用技術による効果
- Railsにより、短期間での開発と認証・API実装を効率化。
- MySQLにより、大量データの高速処理とデータ整合性を確保。

### Ruby + Rails
バックエンドにはRuby on Railsを採用しました。その主な理由は、**高い開発効率と迅速なプロトタイピング能力**です。Railsは、MVCアーキテクチャを提供し、コントローラー、モデル、ビューの各層にコードを分割することで、機能の追加や変更が容易に行えます。さらに、**ActiveRecordやActionCableなどの豊富な標準機能**が含まれており、外部ライブラリ（Gem）を活用することで、ログイン認証、メール配信、ファイルアップロードなどの一般的な機能を短期間で実装できます。  
Railsは、他のフレームワーク（DjangoやNode.jsのExpressなど）と比較しても、**フルスタックかつ「開発者の幸福」を重視**している点で優れており、特にスピードが重視されるプロジェクトでは高いパフォーマンスを発揮します。また、RubyとRailsのコミュニティは活発でドキュメントも豊富なため、トラブル解決が迅速に行える点も採用の大きな理由です。
### MySQL
データベースにはMySQLを選定しました。MySQLは**パフォーマンスの高さ、安定性、シンプルな運用**に強みがあり、データの一貫性とスケーラビリティを重視するシステムに適しています。PostgreSQLも候補にありましたが、MySQLは特に読み込み速度とシンプルな管理が求められる環境で信頼性が高く、Railsと組み合わせた経験が豊富なため、今回のプロジェクトにはMySQLが最適と判断しました。  
また、MySQLは広く普及しており、**エンジニア間での知見が豊富**であるため、チーム開発やサポート体制の整備においても有利です。
### Puma
アプリケーションサーバーにはPumaを採用しました。Pumaは**マルチスレッド対応で、リクエストの同時処理能力が高い**ため、アクセス集中に強い構成を実現します。特に、PumaはRailsに標準で採用されており、Railsとの親和性が高く、設定が簡単でありながら高いパフォーマンスを提供します。Unicornも候補にありましたが、Pumaは**スレッドベースで効率的にスケール**でき、サーバーリソースを効果的に利用できるため、選定しました。
### Devise + Devise Token Auth
ユーザー認証にはDeviseとDevise Token Authを組み合わせて使用しています。DeviseはRailsで広く使われており、**高いセキュリティと柔軟な認証機能の追加**が可能です。メール認証やパスワードリセットなどの一般的な認証機能が容易に実装でき、セキュアで信頼性のあるユーザー認証を短期間で導入できました。  
また、APIベースのアプリケーションと連携するため、トークンベースの認証が必要であり、**Devise Token Authの導入によりSPAやモバイルアプリケーション**ともシームレスに連携が可能です。この組み合わせにより、シンプルかつ安全に認証機能を実装できることが大きなメリットとなりました。
### AWS Secrets Manager
AWS Secrets Managerは、**機密情報を安全に保管・管理するためのツール**として採用しました。データベースのパスワードやAPIキーなどの機密情報を暗号化して保管し、アプリケーションが必要な時だけ動的に取得できるため、従来の環境変数管理よりも**セキュリティが向上**します。自動ローテーション機能も備えており、セキュリティの強化に加え、システム管理の手間を削減できるため、プロジェクトの安定運用に貢献します。
### Dotenv
開発・本番環境での設定を柔軟に切り替えるため、Dotenvを使用しています。Dotenvは**開発段階での環境変数管理をシンプルに行える**ため、異なる環境ごとの設定を簡単に変更でき、セキュリティの確保と同時に開発効率も向上します。また、AWS Secrets Managerなどの高度な管理ツールとも共存でき、**開発の初期段階での迅速な対応が可能**です。
### Rack CORS
Rack CORSを利用し、**クロスオリジンリソース共有（CORS）を適切に管理**しています。これにより、異なるドメインからのAPIリクエストを安全に許可し、ユーザーエクスペリエンスを損なうことなくセキュリティを確保します。特にフロントエンドとの連携を考慮した際に、CORSの適切な設定は重要であり、セキュリティ要件を満たすための基本的なツールとして採用しました。

### テスト方法
テストにはJestの代わりに**curlコマンド**を使用しています。APIエンドポイントを直接テストするcurlは、軽量かつ直感的で、簡易的な動作確認には十分です。特に、APIのステータス確認やデバッグにおいて、過度な設定が不要で即時性が求められる場面において、curlは非常に効果的です。Jestによるユニットテストも考慮しましたが、今回のプロジェクト規模ではcurlによる直接テストの方が効率的であると判断しました。これにより、迅速にAPIの動作を確認し、開発スピードを維持しています。

## **苦労した点**
開発中に直面した課題やトラブル解決のプロセスを、Qiitaにまとめています。  
- [AWS構築で直面した課題と解決](https://qiita.com/kumazaki-y/items/dc8c9270a6b73df1a765)


---

## インフラ
本プロジェクトのインフラは、AWSを中心に構築され、スケーラビリティと運用効率を重視しています。  
ECSを利用してコンテナのオーケストレーションを行い、APIサーバーの管理を効率化しました。

フロントエンドで生成された静的ファイルのホスティングには、Vercelを採用しています。  
バックエンドAPIの実行にはAWSの各種サービスを利用し、拡張性と運用効率を重視したインフラを構築しました。

### 主な使用技術
- ECS (Elastic Container Service): コンテナのスケーリングと管理。
- RDS (Aurora MySQL): 高性能かつ信頼性のあるリレーショナルデータベース。
- S3 (Simple Storage Service): 静的ファイルの保存とバックアップ管理。
- CloudWatch: ログとメトリクスの監視。
- Step Functions: ワークフロー管理の自動化。

- **Vercel**：静的ファイルホスティング。
- **VPC (Virtual Private Cloud)**：ネットワーク範囲を管理 (CIDR: 10.0.0.0/16)。
- **IGW (Internet Gateway)**：パブリックサブネット用のインターネットゲートウェイ。
- **パブリックサブネット**：外部と通信が必要なリソースを配置（例：ロードバランサー）。
- **ALB (Application Load Balancer)**：リクエストをECSタスクに分散。
- **プライベートサブネット**：データベースやアプリケーションサーバーを配置し、外部からのアクセスを制限。
- **ECS (Elastic Container Service)**：コンテナのオーケストレーションを管理。
- **RDS (Aurora MySQL)**：リレーショナルデータベース (RDB)。
- **ECR (Elastic Container Registry)**：Dockerイメージを保存。
- **IAM (Identity and Access Management)**：アクセス権限の管理。
- **Amazon SES (Simple Email Service)**：カスタムドメインからのメール送信。
- **Certificate Manager**：SSL/TLS証明書の発行。
- **CloudWatch**：ログ管理とモニタリング。
- **AWS Lambda**：未認証ユーザーの自動削除処理を実行。
  - AWS EventBridgeと連携して定期実行。
  - Secrets Managerを利用し、安全な認証情報管理を実現。
- **S3 (Simple Storage Service)**：RDSスナップショットの保存とバックアップ管理。

### 技術選定理由
- ECS: コンテナ化されたAPIサーバーを効率的にデプロイ・スケーリング可能。  
- RDS: データ整合性と高い読み取り性能を持つリレーショナルデータベース。  
- S3: 高耐久性のストレージサービスで、バックアップと静的リソース管理を効率化。  
- CloudWatch: リアルタイムの監視とログ管理を実現し、障害検知を迅速化。  
- Step Functions: サーバーのスケジュール起動や停止など、運用コストを削減するために採用。



### インフラ構成図
アプリケーションの基本的な処理の流れは以下の通りです：
1. ユーザーはVercelにデプロイされたフロントエンドアプリケーションにアクセス。
2. APIリクエストは、パブリックサブネット内のALB (Application Load Balancer) を通じてバックエンドに送信。
3. ALBは、ECS (Elastic Container Service) によって管理されるRailsアプリケーションにリクエストを転送。
4. ECSは、以下の処理を実行：
   - RDSへのデータベースアクセス。
   - Amazon SESを利用したメール送信。
   - CloudWatchにログを送信し、監視・管理を実施。
以下は、この流れを示した構成図です：
![インフラ構成図](./front/public/images/infra.png)

### 採用技術による効果
- 自動スケーリングやモニタリング機能により、可用性とパフォーマンスを最適化。  
- S3を活用したバックアップ管理でデータ損失リスクを最小化。


### ECSとECRの連携
ECSはECRから最新のDockerイメージを取得し、アプリケーションのコンテナを実行します。この構成により、迅速かつセキュアなデプロイが可能です。業務での継続的デリバリーを見据えた設計となっています。
### ECSからCloudWatchへのログ送信
ECSは、アプリケーションの動作ログやエラーログをCloudWatchに送信します。これにより、エラー発生時の迅速な監視やトラブルシューティングが可能です。
### ALBとIGWの役割
ALBは、IGWを介してユーザーリクエストを受け取り、適切なECSタスクに振り分けます。HTTPS通信をサポートし、セキュリティとスケーラビリティを担保します。

### RDSの配置とセキュリティ設計
RDSはプライベートサブネットに配置され、外部からの直接アクセスを遮断しています。ECSのみがアクセス可能な設計により、安全なデータ管理を実現しています。

### Lambdaによる未認証ユーザーの自動削除
AWS Lambdaを活用し、未認証ユーザーの自動削除機能を実現しました。
1. **EventBridge**：スケジュール実行を設定。
2. **Secrets Manager**：認証情報の安全な管理を実施。
3. **RDSとの接続**：プライベートサブネット内で安全に通信。

### S3を活用したRDSのバックアップ管理
RDSスナップショットを定期的にS3へエクスポート。高い耐久性とコスト効率の良さから、長期的なバックアップストレージとして最適です。この設計により、データ損失リスクを最小化し、運用効率を向上させています。

## **苦労した点**
開発中に直面した課題やトラブル解決のプロセスを、Qiitaにまとめています。  
- [AWS構築で直面した課題と解決](https://qiita.com/kumazaki-y/items/dc8c9270a6b73df1a765)




## アプリ画面
### ホーム
![ホーム](./front/public/images/home.png)
### 認証関連
#### ゲストログイン
登録不要で簡単にアプリの機能を試せるため、初めてのユーザーでも操作を気軽に体験できます。  
![ゲストログイン](./front/public/images/guestlogin.gif)
#### ログイン
入力時と送信時にバリデーションを行い、セキュリティとユーザー体験を向上させています。
- 入力時バリデーション
![ログイン入力時バリデーション](./front/public/images/login_input.png)
- 送信時バリデーション
![ログイン送信時バリデーション](./front/public/images/login_submit.png)
#### ユーザー登録
入力時と送信時にバリデーションを行い、セキュリティとユーザー体験を向上させています。
- 入力時バリデーション
![登録入力時バリデーション](./front/public/images/registration_input.png)
- 送信時バリデーション
![登録送信時バリデーション](./front/public/images/registration_submit.png)
#### メールアドレス認証
- 認証確認通知
登録リクエスト送信時に、一定時間内に認証が必要なことを画面に表示します。
![認証確認通知](./front/public/images/certification.png)
- 認証用メール
新規登録後に送信される認証リンク付きのメールを通じて、アカウントの有効性を確認します。
![認証確認通知](./front/public/images/certification_mail.png)
#### 認証メール再送信
認証メールの有効期限が切れたときに再送信を行えます。未登録のメールアドレスには送信できません。
 - 送信時バリデーション
![再送信](./front/public/images/resubmit_submit.png)
#### パスワードリセット
パスワードを忘れた場合に再設定リクエストを送信できます。
- 再設定リクエスト入力時バリデーション
![再設定リクエスト入力時バリデーション](./front/public/images/reset_input.png)
- リクエスト送信時バリデーション
![再設定リクエスト送信時バリデーション](./front/public/images/reset_submit.png)
- 再設定用メール
リンク付きメールを送信し、パスワード再設定画面へ案内します。
![再設定用メール](./front/public/images/reset_mail.png)
- 再設定画面入力時バリデーション
再設定用のリンクをクリックすると開くことができる再設定画面で、新しいパスワードを設定します。
![再設定入力時バリデーション](./front/public/images/reset.png)


### タスク管理
#### ボードCRUD
ボード（タスクグループ）の作成、編集、削除が簡単に行えます。  
![ボードCURD](./front/public/images/board.gif)
#### タスクCRUD
タスクの作成、編集、削除が簡単に行えます。 
![タスクCURD](./front/public/images/task.gif)
#### 検索
検索バーを使用して、特定の単語を含むボードを抽出することができます。  
![検索](./front/public/images/search.gif)
#### 絞り込み
フィルター機能を活用して、完了・未完了のステータス別にタスクを絞り込めます。  
![絞り込み](./front/public/images/narrowdown.gif)
#### 並び替え
直感的な操作でタスクの優先順位を調整できます。
![並び替え](./front/public/images/sort.gif)

## 開発記録
開発中に直面した課題を以下の記事にまとめています。

### フロントエンド
- [eslintrc.jsonのproject設定でtsconfig.jsonが読みこなかったケース](https://qiita.com/kumazaki-y/items/b8c3b887a236a2465b5f)  
  → ESLintの設定で発生したエラーを調査し、tsconfig.jsonの構造変更で解決。
- [TypeScriptのリテラル型・タプル型・ユニオン型の整理](https://qiita.com/kumazaki-y/items/7dde8fd8ef4f4acf8082)  

### 開発環境
- [モノレポ構成でつまづいたリバースプロキシとCORSの問題](https://qiita.com/kumazaki-y/items/7acbbfdbac9a838477a1)  
- [Vite×ReactのビルドをDockerで行ったときに出たエラー](https://qiita.com/kumazaki-y/items/9faf6ab4712d4c6e5c72)
